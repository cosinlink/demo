// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

import "forge-std/Test.sol";
import "./interface.sol";
import "../src/PegToken.sol";
import "../lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol";
import "../lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

contract BUSDContractTest is DSTest {
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    address dev = 0xE864012851355978aB30a89eAafEEFFEc45359cd;
    address proxyAdminOwner = 0x583C8F6d4FF765713BdC61E92B6B4AdAD700ddd6;

    PegToken busdImpl = PegToken(0x50F03509E6f2744f1411ca344a03F7f40ED571Ce);
    address payable busdProxy = payable(0xF300bdD6Dbb5F8DF6bB4B6dF01C15775C803E12a);
    ProxyAdmin proxyAdmin = ProxyAdmin(0x447608B7dDFC886609f985cd150C8Cc8320f0b23);

    address expectedNewOwner = 0x4A13E986a4B8E123721aA1F621E046fe3b74F724;
    function setUp() public {
        // fork avax mainnet at block 18963042
        cheats.createSelectFork("avax", 18963042);
    }

    function test_basicInfo() public {
        emit log_named_uint("AVAX balance of dev:", dev.balance);
        emit log_named_address("owner of proxyAdmin:", proxyAdmin.owner());
        assert(proxyAdminOwner == proxyAdmin.owner());

        emit log_named_address("owner of BUSD:", PegToken(busdProxy).owner());
        assert(dev == PegToken(busdProxy).owner());
    }

    function testRevert_RepeatInitialize() public {
        cheats.prank(dev);
        cheats.expectRevert("Initializable: contract is already initialized");
        PegToken(busdProxy).initialize("xxx", "yyy");
    }

    function testRevert_admin() public {
        cheats.prank(dev);
        cheats.expectRevert();
        emit log_named_address(" of proxy:", TransparentUpgradeableProxy(busdProxy).admin());
    }

    function test_admin() public {
        cheats.prank(address(proxyAdmin));
        emit log_named_address("proxyAdmin of proxy:", TransparentUpgradeableProxy(busdProxy).admin());
    }

    function testRevert_pullOwnership() public {
        cheats.prank(dev);
        cheats.expectRevert("Ownable: caller is not the proposed owner");
        PegToken(busdProxy).pullOwnership();
    }

    function test_pullOwnership() public {
        emit log_named_address("Before pullOwnership, owner of BUSD:", PegToken(busdProxy).owner());
        assert(dev == PegToken(busdProxy).owner());

        cheats.prank(expectedNewOwner);
        PegToken(busdProxy).pullOwnership();

        emit log_named_address("After pullOwnership, owner of BUSD:", PegToken(busdProxy).owner());
        assert(expectedNewOwner == PegToken(busdProxy).owner());
    }

}
